<?php

/**
 * @file
 * Contains stanford_migrate.module.
 */

use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Installer\InstallerKernel;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Entity\Entity\EntityViewDisplay;
use Drupal\migrate\Exception\RequirementsException;
use Drupal\migrate\MigrateMessage;
use Drupal\migrate\Plugin\MigrateIdMapInterface;
use Drupal\migrate\Plugin\MigrationInterface;
use Drupal\migrate\Plugin\RequirementsInterface;
use Drupal\migrate_plus\Entity\Migration;
use Drupal\migrate_tools\MigrateExecutable;
use Drupal\node\NodeInterface;
use Drupal\ultimate_cron\CronJobInterface;

/**
 * Implements hook_help().
 */
function stanford_migrate_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the stanford_migrate module.
    case 'help.page.stanford_migrate':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Adds more functionality to migrate and migrate plus modules') . '</p>';
      return $output;

    default:
  }
}

/**
 * Get the migration that imported the given node.
 *
 * @param \Drupal\node\NodeInterface $node
 *   Node entity.
 *
 * @return array|\Drupal\migrate_plus\Entity\MigrationInterface|mixed
 *   Migration entity or null/false if none found.
 */
function stanford_migrate_get_migration(NodeInterface $node) {
  // Use a static variable so that it doesn't look up the migrations multiple
  // times.
  $node_migration = &drupal_static(__FUNCTION__ . $node->id());
  if (!is_null($node_migration)) {
    return $node_migration;
  }
  // Set the static to false and check for null above. If the first attempt to
  // find a migration doesn't show anything, we don't want to continue checking.
  $node_migration = FALSE;

  $plugin_manager = \Drupal::service('plugin.manager.migration');

  // Load only migrations that are enabled.
  $migrations = \Drupal::entityTypeManager()
    ->getStorage('migration')
    ->loadByProperties(['status' => 1]);

  // Loop through the migration entities, build their migration plugins so that
  // we can dig into their source mapping data.
  /** @var \Drupal\migrate_plus\Entity\MigrationInterface $migration */
  foreach ($migrations as $migration) {

    // This migrate entity has methods that allow easy queries on the
    // migrate_map tables.
    /** @var \Drupal\migrate\Plugin\MigrationInterface $migrate */
    $migrate = $plugin_manager->createInstance($migration->id());
    // CSV Imported content can be ignored since it's normally a one time thing.
    if (!$migrate || $migrate->getSourcePlugin()->getPluginId() == 'csv') {
      continue;
    }

    $destination_ids = $migrate->getDestinationPlugin()->getIds();

    // Ignore any migrate plugin that doesn't map to nodes.
    if (isset($destination_ids['nid'])) {

      // If the migrate id map returns something, that means this node is tied
      // to this migration. Set the static variable for later references and
      // get out of here.
      $row_data = $migrate->getIdMap()
        ->getRowByDestination(['nid' => $node->id()]);
      if (!empty($row_data) && $row_data['source_row_status'] != MigrateIdMapInterface::STATUS_IGNORED) {
        $node_migration = $migration;
        return $migration;
      }
    }
  }

}

/**
 * Implements hook_entity_form_display_alter().
 */
function stanford_migrate_entity_form_display_alter(EntityFormDisplayInterface $form_display, array $context) {
  // We only care about nodes, but this could be expanded later if more entities
  // are imported.
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($context['entity_type'] != 'node' || !$node) {
    return;
  }

  $migration = stanford_migrate_get_migration($node);
  // Check if the current node was imported.
  if (!$migration) {
    return;
  }

  // Grab the default display settings for use later.
  $default_display = EntityViewDisplay::load("node.{$node->bundle()}.default");

  $field_definitions = $form_display->get('fieldDefinitions');
  foreach ($form_display->getComponents() as $field_name => $component) {

    // Make sure the field component is one of the field definitions.
    if (empty($field_definitions[$field_name])) {
      continue;
    }

    // When edit an existing node that was imported via migrate module, mark the
    // fields that are mapped from migration as readonly.
    $field_definition = $field_definitions[$field_name];
    $columns = $field_definition->getFieldStorageDefinition()->getColumns();
    $processing = !empty($migration->process[$field_name]);

    // This will check if a migrate process is mapped to a specific column on
    // the field.
    foreach (array_keys($columns) as $column) {
      $processing = $processing ?: !empty($migration->process["$field_name/$column"]);
    }

    // If the migration destination has the `overwrite_properties` configured,
    // those fields specifically should be locked, not the other fields that
    // are not designated in the original process configuration.
    if ($processing && !empty($migration->get('destination')['overwrite_properties'])) {
      // If the current field doesn't exist in the overwrite_properties, it
      // should not be considered to be processing since it's a one time only
      // import.
      $processing = FALSE;

      foreach ($migration->get('destination')['overwrite_properties'] as $overwrite_property) {
        // If any part of the field is set to overwrite, lock the whole field
        // down.
        $overwrite_property = strstr($overwrite_property, '/', TRUE) ?: $overwrite_property;
        if ($field_name == $overwrite_property) {
          $processing = TRUE;
        }
      }
    }

    if ($processing) {
      \Drupal::messenger()
        ->addWarning(t('Some fields can not be edited since they contain imported & synced data.'));

      // If the default display is configured with some settings, let's use that
      // for the best display on the entity form. If it's not configured, the
      // readonly_field_widget module will use some default display settings.
      if ($display_component = $default_display->getComponent($field_name)) {
        $component['settings']['formatter_type'] = $display_component['type'];
        $component['settings']['formatter_settings'] = $display_component['settings'];
      }
      $component['type'] = 'readonly_field_widget';
      $form_display->setComponent($field_name, $component);
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function stanford_migrate_preprocess_field(&$variables) {
  if (
    !empty($variables['element']['#parents']) &&
    in_array('readonly_field', $variables['element']['#parents'])
  ) {
    // Wrap the readonly form fields with classes so that they can be identified
    // more easily to the user.
    $variables['attributes']['class'][] = 'messages';
    $variables['attributes']['class'][] = 'messages--warning';
    $variables['attributes']['class'][] = 'messages--readonly';
    $variables['#attached']['library'][] = 'stanford_migrate/readonly';
  }
}

/**
 * Implements hook_config_readonly_whitelist_patterns().
 */
function stanford_migrate_config_readonly_whitelist_patterns() {
  $configs = [];
  /** @var \Drupal\migrate_plus\Entity\MigrationInterface $migration */
  foreach (Migration::loadMultiple() as $migration) {
    if ($migration->get('source')['plugin'] == 'csv') {
      $configs[] = $migration->getConfigDependencyName();
    }
  }
  return $configs;
}

/**
 * Implements hook_config_schema_info_alter().
 */
function stanford_migrate_config_schema_info_alter(&$definitions) {
  $definitions['migrate_plus.migration.*']['mapping']['status'] = [
    'type' => 'boolean',
    'label' => 'Active',
  ];
}

/**
 * Migration callback to just get the current timestamp.
 *
 * We use this function in migration callback processes because using `time` as
 * the callback produces messages about "function accepts 0 arguments, 1
 * argument passed". So we just have our own callback that takes the argument
 * from the migration process and does nothing with it.
 *
 * @param mixed $arg
 *   Passed parameter from migration plugin `callback`.
 *
 * @return int
 *   Current timestamp.
 *
 * @see \Drupal\migrate\Plugin\migrate\process\Callback::transform()
 */
function _stanford_migrate_get_time($arg = NULL) {
  return time();
}

/**
 * Implements hook_entity_type_alter().
 */
function stanford_migrate_entity_type_alter(array &$entity_types) {
  if (\Drupal::moduleHandler()->moduleExists('migrate_source_csv')) {
    $entity_types['migration']->setFormClass('csv-upload', 'Drupal\stanford_migrate\Form\StanfordMigrateCsvImportForm');
    $entity_types['migration']->setLinkTemplate('csv-upload', '/admin/structure/migrate/manage/{migration_group}/migrations/{migration}/csv-upload');
    $entity_types['migration']->setLinkTemplate('csv-template', '/admin/structure/migrate/manage/{migration_group}/migrations/{migration}/csv-template');
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function stanford_migrate_migration_delete(Migration $entity) {
  // Clean up the state if the migration is deleted.
  \Drupal::state()->delete("stanford_migrate.csv.{$entity->id()}");
}

/**
 * Implements hook_migrate_id_map_info_alter().
 */
function stanford_migrate_migrate_id_map_info_alter(&$definitions) {
  $definitions['sql']['class'] = '\Drupal\stanford_migrate\Plugin\migrate\id_map\StanfordSql';
}

/**
 * Implements hook_migrate_source_info_alter().
 */
function stanford_migrate_migrate_source_info_alter(array &$definitions) {
  $definitions['url']['class'] = '\Drupal\stanford_migrate\Plugin\migrate\source\StanfordUrl';
}

/**
 * Implements hook_data_parser_info_alter().
 */
function stanford_migrate_data_parser_info_alter(array &$definitions) {
  $definitions['json']['class'] = '\Drupal\stanford_migrate\Plugin\migrate_plus\data_parser\StanfordJson';
  $definitions['simple_xml']['class'] = '\Drupal\stanford_migrate\Plugin\migrate_plus\data_parser\StanfordSimpleXml';
}

/**
 * Implements hook_migrate_process_info_alter().
 */
function stanford_migrate_migrate_process_info_alter(array &$definitions) {
  if (!empty($definitions['file_import'])) {
    $definitions['file_import']['class'] = '\Drupal\stanford_migrate\Plugin\migrate\process\StanfordFileImport';
  }
}

/**
 * Implements hook_entity_delete().
 *
 * When an entity is manually deleted from the database, we want to remove it
 * from the migration mapping.
 */
function stanford_migrate_entity_delete(EntityInterface $entity) {
  /** @var \Drupal\migrate\Plugin\MigrationInterface $migration */
  foreach (stanford_migrate_migration_list() as $group => $migrations) {
    foreach ($migrations as $migration) {
      $destination = $migration->getDestinationConfiguration();

      // It should always be set. but its just a safety valve.
      if (!isset($destination['plugin'])) {
        continue;
      }

      if (
        strpos($destination['plugin'], 'entity:') !== FALSE ||
        strpos($destination['plugin'], 'entity_reference_revisions:') !== FALSE
      ) {
        [, $type] = explode(':', $destination['plugin']);

        if ($type == $entity->getEntityTypeId()) {
          $lookup_values = [];
          $lookup_ids = array_keys($migration->getDestinationPlugin()
            ->getIds());

          foreach ($lookup_ids as $id_key) {
            $lookup_values[$id_key] = $entity->get($id_key)->getString();
          }
          $migration->getIdMap()
            ->deleteDestination($lookup_values);
        }
      }
    }
  }
}

/**
 * Ultimate cron callback function to execute a migration group.
 *
 * The entity id should be in the form `stanford_migrate_{migrate_group_id}` to
 * execute that group.
 *
 * @param \Drupal\ultimate_cron\CronJobInterface $cron_entity
 *   Ultimate cron entity.
 */
function stanford_migrate_ultimate_cron_task(CronJobInterface $cron_entity) {
  // Invalidate migration plugins to gather any changes to config entities
  // before running import. This allows for any changes to the source urls.
  Cache::invalidateTags(['migration_plugins']);

  $logger = \Drupal::logger('stanford_migrate');
  $migrations = stanford_migrate_migration_list();

  $migration_group = str_replace('stanford_migrate_', '', $cron_entity->id());
  // Execute the migration entities in the provided migration group.
  if ($migration_group && !empty($migrations[$migration_group])) {
    try {
      array_walk($migrations[$migration_group], 'stanford_migrate_execute_migration');
    }
    catch (Exception $e) {

      // Log any errors that we encounter.
      $logger->error('Unable to run migration importer: @group @message', [
        '@group' => $migration_group,
        '@message' => $e->getMessage(),
      ]);
    }

    return;
  }
  $logger->info('No migration group @group exists. No migration executed.', ['@group' => $migration_group]);
}

/**
 * Executes a single migration, taken from drush command in migrate_tools.
 *
 * @param \Drupal\migrate\Plugin\MigrationInterface $migration
 *   The migration to execute.
 * @param string $migration_id
 *   The migration ID (not used, just an artifact of array_walk()).
 * @param array $options
 *   Array of options to pass into the migration import.
 *
 * @see \Drupal\migrate_tools\Commands\MigrateToolsCommands::executeMigration()
 */
function stanford_migrate_execute_migration(MigrationInterface $migration, $migration_id, array $options = []) {
  // Reset migration status so that it can be executed again.
  $migration->interruptMigration(MigrationInterface::RESULT_STOPPED);
  $migration->setStatus(MigrationInterface::STATUS_IDLE);

  // Keep track of all migrations run during this command so the same
  // migration is not run multiple times.
  static $executed_migrations = [];

  // Execute all the required migrations first before running this one.
  $definition = $migration->getPluginDefinition();
  $required_migrations = $definition['migration_dependencies']['required'] ?? [];
  $required_migrations = array_filter($required_migrations, function ($value) use ($executed_migrations) {
    return !isset($executed_migrations[$value]);
  });

  if (!empty($required_migrations)) {
    $manager = \Drupal::service('plugin.manager.migration');
    $required_migrations = $manager->createInstances($required_migrations);
    $dependency_options = array_merge($options, ['is_dependency' => TRUE]);
    array_walk($required_migrations, 'stanford_migrate_execute_migration', $dependency_options);
    $executed_migrations += $required_migrations;
  }

  // Finally run this migration.
  try {
    $log = new MigrateMessage();
    $executable = new MigrateExecutable($migration, $log, $options);
    $executable->import();
    $executed_migrations[$migration_id] = $migration_id;
  }
  catch (Exception $e) {
    \Drupal::logger('stanford_migrate')
      ->critical('Unable to execute importer @id: @message', [
        '@id' => $migration_id,
        '@message' => $e->getMessage(),
      ]);
  }
}

/**
 * Retrieve a list of active migrations, partially taken from migrate_tools.
 *
 * @return \Drupal\migrate\Plugin\MigrationInterface[][]
 *   An array keyed by migration group, each value containing an array of
 *   migrations or an empty array if no migrations match the input criteria.
 *
 * @see \Drupal\migrate_tools\Commands\MigrateToolsCommands::migrationsList()
 */
function stanford_migrate_migration_list() {
  // Don't run the migrations when drupal is being installed.
  if (InstallerKernel::installationAttempted()) {
    return [];
  }

  $manager = \Drupal::service('plugin.manager.migration');
  $matched_migrations = $manager->createInstances(array_keys(Migration::loadMultiple()));

  // Do not return any migrations which fail to meet requirements.
  /** @var \Drupal\migrate\Plugin\MigrationInterface $migration */
  foreach ($matched_migrations as $id => $migration) {
    if ($migration->getSourcePlugin() instanceof RequirementsInterface) {
      // Status might not be set on the entity so check for it first.
      if (isset($migration->status) && !$migration->status) {
        continue;
      }
      try {
        $migration->getSourcePlugin()->checkRequirements();
      }
      catch (RequirementsException $e) {
        \Drupal::logger('stanford_migrate')
          ->error('Unable to execute migration @name: @message', [
            '@name' => $migration->label(),
            '@message' => $e->getMessage(),
          ]);
        unset($matched_migrations[$id]);
      }
    }
  }

  // Sort the matched migrations by group.
  if (!empty($matched_migrations)) {
    /** @var \Drupal\migrate\Plugin\Migration $migration */
    foreach ($matched_migrations as $id => $migration) {
      $definition = $migration->getPluginDefinition();
      $configured_group_id = $definition['migration_group'] ?? 'default';
      $migrations[$configured_group_id][$id] = $migration;
    }
  }

  return isset($migrations) ? $migrations : [];
}
